"""
Учитывая целочисленный массив numsи целое число val, удалите все вхождения valin nums -place . Порядок элементов может быть изменен. Затем верните количество элементов, в numsкоторых не равныval .
Учитывайте количество элементов, в numsкоторых не равны val, kчтобы их приняли, вам необходимо сделать следующее:
Измените массив numsтак, чтобы первые kэлементы numsсодержали элементы, не равные val. Остальные элементы numsне важны, как и размер nums.
Возвращаться k.
Пользовательский судья:
Судья проверит ваше решение с помощью следующего кода:
int[] nums = [...]; // Входной массив
интервал вал = ...; // Значение для удаления
int[] ожидаемые числа = [...]; // Ожидаемый ответ правильной длины.
                            // Он отсортирован без значений, равных val.
int k = RemoveElement(nums, val); // Вызывает вашу реализацию
утверждать k == ожидаемые числа.длина;
сортировка (числа, 0, к); // Сортируем первые k элементов числа nums
for (int i = 0; i <actualLength; i++) {
    утверждать nums[i] == ожидаемыеNums[i];
}
Если все утверждения пройдены, ваше решение будет принято .
Пример 1:
Ввод: nums = [3,2,2,3], val = 3
Выход: 2, nums = [2,2,_,_]
Объяснение: Ваша функция должна возвращать k = 2, причем первые два элемента nums должны быть 2.
Не имеет значения, что вы оставите после возвращенного k (следовательно, они являются подчеркиванием).
Пример 2:
Ввод: nums = [0,1,2,2,3,0,4,2], val = 2
Выход: 5, nums = [0,1,4,0,3,_,_,_]
Пояснение: Ваша функция должна возвращать k = 5, причем первые пять элементов nums содержат 0, 0, 1, 3 и 4.
Обратите внимание, что пять элементов могут быть возвращены в любом порядке.
Не имеет значения, что вы оставите после возвращенного k (следовательно, они являются подчеркиванием).
"""

nums = [0, 1, 2, 2, 3, 0, 4, 2]
val = 2

for i in range(len(nums)):
    x = nums.pop(0)
    if x == val:
        continue
    else:
        nums.append(x)
print(nums)
